# 如何使用Xlib编程

本节将回顾在你写任何代码之前对X编程的重要了解，描述X程序的设计、编写和调试的内容，这些应该能让你在正式开始自己的编程时有一个更好的开始。

**第3章 “基本窗口程序”** 中会对这节的很多问题有详细的描述，那么现在就开始本节的内容！

## 设计一个X应用程序

首先让我们概述一下任何X应用程序必须执行的主要任务。

从 **用户的角度** 来看，几乎任何窗口系统下的任何应用程序都会做一些显而易见的事情：在屏幕上创建一个适当大小的窗口，为窗口中的一些文本/图形确定一个位置，在窗口中绘图，并接受键盘/鼠标的输入，相应地改变屏幕。从本质上讲，应用程序的顶层窗口的处理方式与PC上的整个屏幕的处理方式非常相似，这些任务是直截了当的，大多数程序员应该会发现它们很相似。

当然，由于一些窗口系统，特别是X窗口系统的独特功能，还有一些复杂情况。这些复杂情况决定了在X下运行的应用程序的设计要求。

## 设计要求

下面四段描述了X应用程序必须做的一些不明显的事情。这些是应用程序在X下正常运行所必须做的事情，但普通用户可能不会注意到或知道。

1. 首先，X允许工作站连接在同一个网络中，在这个网络中，只要得到许可，任何主机或节点都可以运行X程序，并在任何其他节点上显示这些程序。这意味着程序必须能够接受用户对使用哪个显示器的指定。(记住，每个显示器都有它自己的服务器，所以选择显示器就相当于在客户端和一个特定的服务器之间建立连接）。这个要求是内置的，实际上不需要编程，这在 **第3.2.2节 "连接到服务器"** 中有所描述。
2. 第二，应用程序必须负责任地使用显示器的有限资源，主要是屏幕空间和色彩映射空间。这是因为在一个屏幕上可能有许多应用程序同时运行，共享这些有限的资源。负责管理这些有限资源的客户端是窗口管理器，每个应用程序和窗口管理器之间的通信有一定的要求，以确保竞争的需求可以被公平地仲裁，并确保用户看到一个一致的用户界面。对于简单的应用程序来说，这些要求不难满足，但对于复杂的应用程序来说，它们会变得更加复杂。这个领域将在 **第12章 "客户间通信"** 中描述。
3. 第三，其他的客户端可能会在你的客户端上方移动，然后再移开，这就要求你的客户端必须重新绘制它的窗口。X不能维护无限数量的重叠窗口的内容，就算它试图维护哪怕是几个窗口也是低效的。你的客户会被告知什么时候需要重绘，在哪些地方需要重绘。这个要求并不难满足，但它鼓励以一种记录每个窗口的当前 **"state"** 的方式进行编程，以便可以重新绘制。对 **Expose** 事件的处理在 **第3.2.13节 "设置事件收集循环"** 中描述。
4. 第四，用户可以调整你的应用程序的大小，所以你的程序应该能够重新计算子窗口和图形的尺寸和位置，以适应给定的窗口。

简而言之，这四个方面是对X程序基本功能之外的所有要求。幸运的是，对于大多数没有独特需求（如自定义颜色映射）的客户来说，这些要求是可以直接满足的。

## 用户界面

设计一个应用程序的第一步是要确定它的功能是什么。确定用户将如何调用这些功能可能是下一步。也就是需要设计一个用户界面。

X被特意设计为 "无策略（policy free）"，因此它不像许多其他窗口系统那样带有标准的用户界面。你不得不自己编写用户界面的所有部分，除非你选择使用一个可用的工具包（比如QT、GTK等）。使用工具包可以使构建用户界面变得更加容易，我们也强烈建议使用。否则，你必须自己编写菜单、命令按钮、对话框等等，并确定它们的使用方式。有很多方法来编写这些用户界面功能，我们也在 **第16章 "窗口管理"** 中的一个程序中实现了一个简单的菜单，在 **第9章 "键盘和指针 "** 中也有一个对话框程序的例子，编写一个命令按钮例程应该是很简单的。

在用户界面的设计中，相互作用的关键因素是窗口的层次结构以及事件的选择和处理（主要是指针和键盘事件）。由于这些设备事件在层次结构中的传播取决于它们是否被传递过程中的窗口选中，层次结构和事件选择共同决定了事件的接收方式。对于每一个用户操作，必须有一处（可能是唯一的，也可能是几个不同的用户操作所共有的）用于事件处理的代码，产生对用户的某种响应，要么是可见的变化，要么是信息，要么是信息声音。因此，事件循环的工作便是区分所有可能的用户行为并调用适当的代码。在主事件循环中，每个事件类型的 case 语句都必须有另一个分支，这取决于接收事件的窗口，然后再调用执行用户请求的动作的函数。事件类型和发生事件的窗口只是两个最常见的事件结构成员（也可能有基于其他成员的额外分支语句），例如，在发生按键或按钮时，哪些按键或按钮被按住了。

特别是对于复杂的程序，仔细设计窗口的层次结构和事件的选择可以简化代码，并节省调试的时间。我们建议画出窗口的层次结构和每个窗口选择的事件类型，然后画出将被传播到祖先窗口的事件。这有助于在编写任何代码之前发现问题。

## 资源和用户的可定制性

一个应用程序不应该对X下所有可能的选项（比如颜色和字体）写死到程序里。应该允许用户指定所有窗口的颜色、使用的字体、使用的显示器和屏幕、应用程序的初始尺寸和位置，以及其他大量的标准和应用程序特定的选项。

一个应用程序应该提供命令行参数，但是有太多的选项，不可能把所有的选项都支持为命令行参数。X的开发者为用户设计了一种更好的方法来指定选项，称为资源。用户将所需的选项放在一个使用特定格式的文件中，并运行X应用程序 `xrdb` ，指定这个文件作为命令行参数。`xrdb` 在根窗口上放置一个属性，其值就是这个文件的内容。应用程序使用一组 Xlib 例程，统称为 **资源管理器** ，为每个需要的选项返回一个设置。例程 **`XGetDefault()`** 使这个过程对应用程序来说相当容易。如果用户没有调用 `xrdb` 来设置根窗口上的属性，**`XGetDefault()`** 会在用户的主目录中读取一个名为 **`.Xdefaults`** 的文件。应用程序本身应该包含每个选项的默认值，以防这些来源都不包含其中一个选项的值。

**这种对资源的使用与服务器资源一词完全不同，后者是指窗口和GC。** 

一个资源规范是一个键值对。一个键值对可能只适用于一个特定的应用程序中的一个特定的窗口，也可能适用于整个应用程序，也可能适用于某一类的应用程序，如编辑器，或所有应用程序。**用来寻找特定变量值的算法与普通的数据库管理器的操作完全不同** 。给定一个不完整的键的规格，它使用一种算法来确定资源数据库中的哪个键是最匹配的，并返回指定的值。**它总是只返回一个值** 。这与普通的数据库管理器有很大的不同（如果查询的键太笼统，它会返回许多值）。资源管理器和提供用户可定制性在 **第13章 "管理用户偏好"** 中有详细描述。

##  编译和链接X程序

要使用X库中的所有函数，你需要包含头文件 **`<X11/Xlib.h>`** 、**`<X11/Xutil.h>`** 、**`<X11/keysym.h>`** 和 **`<X11/Xresource.h>`** 。这些文件定义了 **数据结构、宏和符号，并声明了函数的类型** 。 **`<X11/Xos.h>`** 可能也会用到，它引入了某些在C程序中常用的头文件，这些文件在不同的操作系统中名称或位置不同，特别是 System V 和 BSD 。要编译和链接你的 Xlib 程序，只需要使用：

```bash
cc −g −o <编译后可执行文件> <源代码文件> −lX11
```

**`-lX11`** 选项指定链接标准 Xlib 库 。

## 命名约定

对于 Xlib 函数和常量的命名有一些约定。你应该熟悉这些约定，以便正确命名你自己的函数和常量，主要的约定有：

- 所有 Xlib 函数的名称都以X（大写）开头，复合词的构造是将每个词的第一个字母大写。例如，一个典型的函数名称是 **`XAllocColor()`** 。
- 大多数用户可见的数据结构和结构类型的名称以X（大写）开头。唯一的例外是 **Depth** 、**Display** 、**GC** 、**Screen** 、**ScreenFormat** 和 **Visual** 。这六个结构的指针在程序中非常常用，但除非通过预先存在的宏，否则不应直接访问其成员（C语言结构体没有权限控制，就算不推荐访问，你仍然可以访问，不过劝你别这样做！）。
- 数据结构的所有成员的名字都使用小写。在需要的情况下，复合词的结构使用下划线 **\_** 。
- 宏的名称不以X开头。为了将宏与用户符号（都是大写字母）区分开来，宏中每个词的第一个字母都是大写的。（用于 quarks 的宏是这一规则的例外，也许是因为它们曾经是一个独立库的一部分。它们的名字以Xrm开头）。
- 在X头文件中定义的符号常量（#defined）的名称使用混合大小写，每个词的第一个字母大写，并且不以 X 开头。根据现有惯例，小写符号保留给变量，所有大写符号保留给用户符号。唯一的例外是，预定义的原子名称使用全大写字母，用下划线隔开单词。原子名称以 **XA_** 开头，以区别于用户符号。

你应该选择不会与标准 Xlib 函数、宏或常量相混淆的常量和函数名称。用户函数名不应该以X开头，也可以把第一个词的第一个字母小写，以避免与 Xlib 宏混淆。用户常量应该全部采用大写字母。变量名称可以像往常一样用小写字母，如果需要的话，用下划线将单词分开，因为X结构成员的引用总是伴随着作为结构声明的变量。

##  使用结构体、符号和掩码

Xlib 利用了许多结构体和常量的优势。这种编程风格对一些程序员来说可能是陌生的，我们将描述结构体和常量的典型使用方法，这样当你看到这些例子时，就会对这个做法感到熟悉。

指向结构体的指针是向 Xlib 函数指定数据并从其返回数据的主要方式。如果函数返回数据，返回值将是一个指向数据结构体的指针，除非函数返回一个以上的结构，在这种情况下，一个或所有的结构体指针将会作为参数传递给函数。在一些函数中（主要是那些关于颜色的函数），一个指向结构体的参数指定一些信息并返回一些其他信息（返回的信息还是写入这个结构体指针指向的结构中）。

在设置服务器资源的特性时，例如一组窗口属性、图形上下文、颜色映射表中的单元格数值或硬件特性（如按键），结构体和掩码都要作为参数指定。掩码指定了在更新资源值时应该读取指定结构中的哪些值。掩码中的一个比特对应结构体中的一个成员，并且在 Xlib 头文件中定义了一个特殊的常量，在构建掩码时代表该成员。每个掩码常量都有一个比特被设置。掩码参数是由任意数量的掩码常数与位数 **OR** 运算符（ **`|`** ）组合而成。例如，**`CWBackgroundPixmap`** 常数用于表示要读取指定窗口属性结构中的 **`background_pixmap`** 成员，并改变资源中的相应成员（这种方式在 Unix 系统编程中非常常见，你应该习惯这种做法）。

Xlib 中宏定义的常数的另一个主要用途（除了用于掩码）是作为结构体成员本身的值。它们表示在许多选择中哪一个是真的。例如，一些结构成员只能有 **True** 或 **False** 这两个值，再比如，每个事件结构体的类型成员可以有 33 个不同的值，每个值由一个不同的常数表示，如 **Expose** 。定义的常数也被用作返回值。

常数宏定义也用于预定义的原子。正如 **第2.1.4节 "属性和原子"** 中所描述的，原子是一个属性对应的整数值。原子被用来避免在客户端和服务器之间来回传递属性名称字符串。

## 性能优化

性能好的程序用户体验更好，Xlib 程序虽然很棒，但仍然需要我们在编写时注意一些性能方面的优化。比如在允许的情况下，你应该使用不需要 X 服务器回复的 Xlib 函数。也就是说，在经常被调用的函数中，特别是在事件循环中，避免使用名称中含有 **`Fetch`** 、**`Get`** 或 **`Query`** 的 Xlib 函数。这些函数大多从服务器返回信息，因此，它们会受到网络延迟的影响，并会拖慢你的应用程序。这些信息大部分可以从事件中获得。

一般来说，让用户的行为和程序的反应之间的反馈回路尽可能地短。

##  调试X应用程序

程序员应该知道，到目前为止，调试可能是编程中最困难和最耗时的一方面。在这里，你要抓住所有在编写阶段造成的问题，而且往往还有设计阶段的问题。在设计程序时，人们很难预测到所有的问题。

不同以前，现代的大多 IDE 都包含了实时代码检查和运行时代码断点调试，可以提供很多帮助，对于难以直接调试的，下面提到的某些工具也能提供一些帮助。

标准应用程序 **xwininfo** 可以很好地显示一个窗口的信息，包括它的窗口 ID 和名称、父和子窗口的 ID 和名称、所有的窗口属性，以及为该窗口设置的窗口管理器提示。使用 **--help** 可以了解如何只打印需要的信息。

标准应用程序 **xprop** 可以显示窗口上设置的每个属性的名称、类型和值，在调试设置或读取属性的应用程序时非常有用，它还可以显示字体属性。

如果你的应用程序在调试过程中产生了协议错误，关闭 Xlib 的请求缓冲（在 **第2.1.2节 "缓冲"** 中有描述），会更容易找到错误的位置。这是通过 **XSynchronize()** 调用来完成的，该调用紧接在与服务器连接的调用（ **XOpenDisplay()** ）之后。

调试困难的最常见的地方之一是在事件处理方面。出于这个原因，我们建议正式发布程序前（调试和开发阶段）在其事件处理的每个分支的开头都包含 **printf** 语句，这样程序员就可以在一个窗口观察事件的顺序，在另一个窗口观察应用程序的实际运行效果。这个打印语句可以使用 **`#ifdef DEBUG`** 和 **`#endif`** 包裹，这样你就可以在需要调试时，编译加上 **-DDEBUG** 参数，而在正式发布是取消这个参数。

X应用程序很难彻底测试，下面有一些我们推荐进行测试的方面：

- 请确保尝试提升和降低不同窗口的所有组合，以测试应用程序对 **Expose** 事件的反应。它是否进行不必要地重绘或者没有进行重绘。
- 测试按下和抬起不同的鼠标按钮的所有组合，看看是否有什么问题。
- 测试网络不佳情况时的程序表现。
- 尝试在各种不同的X服务器上测试该应用程序。查看是否在彩色和单色系统上都能工作。
- 尝试在不同结构、不同比特和字节顺序的机器上运行该应用程序。
- 测试当你在一个特定的键盘上输入功能键或其他独特的按键时会发生什么。
- 测试如果指定错误的资源或命令行参数集，应用程序是否会崩溃。

如果你的应用程序能够通过所有这些测试，你就已经做得很好了。

## 错误

在使用 Xlib 的程序时，可能遇到三个层次的错误。第一层是通过监控创建服务器资源的例程的返回状态来实现，这使得客户端可以修改请求的参数并再次尝试。第二层是协议错误，通常是由编程错误引起的。第三层是由致命的系统错误引起的，如运行服务器的机器崩溃或网络故障。后两种类型由两个独立的错误处理函数来处理，这些函数可以由客户端设置，但在默认情况下，只是打印一条信息并退出客户端。

作为第一层错误处理的一个例子，客户端应该总是在继续之前检查它是否用 **`XOpenDisplay()`** 成功连接到了显示服务器。如果这个连接没有成功，客户端应该向 **stderr** 打印一条信息，说明发生了什么，以及它试图连接到哪个服务器。这个过程将在 **第三章 "基本窗口程序"** 中演示。

当常规参数不符合接受的范围或 ID 与现有资源不匹配时，会发生 **X协议错误** 。这些类型的错误被发送到 **XErrorHandler** 。致命的错误，如与服务器的连接中断，属于不可恢复的情况，会传递给 **XIOErrorHandler** 。这两个错误处理程序默认显示一个错误信息，然后强制退出程序。

如果你向 **`XSetIOErrorHandler()`** 或 **`XSetErrorHandler()`** 传递函数指针，用户定义的错误处理程序将在错误处理程序中被调用 。如果这两个函数被传递一个 **NULL函数指针** ，会执行各自的默认处理程序。

如果你编写自己的错误处理程序，建议你使用 **`XGetErrorText()`** 或 **`XGetErrorDatabaseText()`** 来获取描述错误代码的字符串，这样可以正确处理扩展的代码。**`XGetErrorDatabaseText()`** 使用资源管理器从文件 **XErrorDB** 中获取错误信息，该文件默认位于 `/usr/lib/X11` 中。

**只有错误处理例程 `XErrorHandler（或你自定义的）才会接收错误事件` 。这些事件不能被选择或被窗口接收** 。

## XErrorEvent结构

**例2-2** 显示了 **`XErrorEvent`** 结构体和它的成员。这个结构体的每个成员的值都由默认的X协议错误处理程序显示。

例2-2：

```c
typedef struct _XErrorEvent {  
    int type;  
    Display *display;            /* 事件来自哪个 Display */  
    XID resourceid;              /* 资源ID */  
    unsigned long serial;        /* 失败请求的序号 */  
    unsigned char error_code;    /* 失败请求的错误代码 */  
    unsigned char request_code;  /* 失败请求的主要操作码 */  
    unsigned char minor_code;    /* 失败请求的次要操作码 */  
} XErrorEvent;
```

下面的列表详细描述了 **`XErrorEvent`** 结构体的每个成员：

- **serial：** 自网络连接打开以来通过网络连接发送的请求数，从1开始。`serial` 与错误消息中报告的最后一个请求之间的差异告诉您要倒数多少个请求才能找到导致错误的请求。
- **request_code：** 对失败的协议请求名称的协议表示，不同错误对应有不同的错请求码。
- **error_code：** 
- **minor_code：** 除非该请求是一个扩展的一部分，否则该值为零。如果是的话，表示扩展中的哪个请求导致了错误。
- **resourceid：** 表示与导致错误的请求相关联的服务器资源之一（窗口、颜色图等）。

## 及时同步错误

由于错误事件发生时并不精确显示，所以通常需要查找协议请求以及错误代码，以确定错误发生在哪个函数中。由于 Xlib 的请求缓冲和其他延迟，你不能依靠调试器来指示错误发生的位置。

使用 **`XSynchronize()`** 来确保协议错误一旦发生就会被显示出来，这很有用。当 **`XSynchronize()`** 被调用时，图形的性能将急剧下降。

## 软件中断

**Xlib 并不处理软件中断** 。因此，如果你从一个信号处理程序中递归调用到 Xlib，程序将挂起或崩溃，这主要是在具有线程或多处理器的系统上的问题。处理信号的正确方法是不要从信号处理程序中调用 Xlib 。

---

#### [上一节](./5.md)

#### [下一章](../3/0.md)














