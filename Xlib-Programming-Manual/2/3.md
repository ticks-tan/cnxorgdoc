# X Graphics 简介

本节会简要介绍在X窗口系统下用于图形（Graphics）的术语和概念。你将在 **第3章 ”基本窗口程序“** 和 **第4章 “窗口属性”** 中看到这些术语，然后我们将在 **第5章 “图形上下文”** 、**第6章 “绘制图形和文本”** 和 **第7章 “颜色”** 中对图形进行深入学习。

## 像素和颜色

X窗口系统被设计用来控制位图显示。在最简单的黑白显示中，每个像素只有一个比特：该比特的状态决定了该像素是黑还是白（0或者1）。而在彩色系统或允许灰度显示的单色系统中，每个像素对应多个比特。

分配给每个像素的多个比特的状态并不直接控制该像素的颜色或灰度强度。相反，它们被用作一个叫做 **颜色映射的查找表** 的索引，如 **图2-3** 所示。在彩色显示器上，一个像素由独立的红、绿、蓝荧光粉组成，每一个都对独立的电子束敏感，这三种颜色的相对强度使眼睛认为它看到的是一种颜色。因此，颜色图包含一个红、绿、蓝（RGB）三色阵列。换句话说，如果一个给定的像素（一个像素值）的比特值是11，那么彩色颜色映射表的第十四个成员的RGB值将显示在屏幕上的那个位置。

图2-3：

![图2-3](./Figures/Figure-2-3.svg)

色域映射的每个成员都被称为颜色单元（color cell），每个颜色单元将一个像素值转化为一组指定的红、绿、蓝值（RGB值）。所有的位图显示器都至少有一个硬件颜色映射，尽管在单色屏幕的情况下，它可能只由两个颜色单元组成。在大多数情况下，客户端都通过只分配他们需要的色块数量并尽可能多地共享单个色块。然而，当客户端有特殊需求时，X允许他们拥有私人色块或创建虚拟色域，然后在必要时将其交换到硬件色域中（前提是它是可写的）。

需要注意的是每个窗口都有可能指定一个不同的颜色映射。这就是颜色映射作为窗口属性这一事实的意义所在。

## 像素与平面（Pixels and Planes）

每个像素的比特数也被称为图形显示器中的平面数。黑白系统有一个平面，彩色显示器有4到28个平面，而灰度显示器通常有2到4个平面。X11最多支持32个平面。

从前面关于每个像素的比特作为颜色映射的索引的讨论中可以推断出，可以同时显示在屏幕上的可能的颜色或灰度的数量是 2n ，其中 n 是显示器中的平面数。(当然，即使在只有几个平面的系统上，也可以以现有的颜色为代价提供额外的颜色，只需将不同的 RGB 值加载到硬件颜色映射（前提它是可写的）。

所有的图形计算都是在像素值转化为 RGB 之前进行的。在绘图请求中指定的源像素值和旧的目标像素值根据平面遮罩、剪辑遮罩和逻辑函数进行组合，以得出最终的目标像素值。平面遮罩、剪辑遮罩和逻辑函数是关于一个叫做 **图形上下文（GC）** 的结构的各个方面，在 **第5章 ”图形上下文“** 中会对其描述。

宏 **`BlackPixel()`** 和 **`WhitePixel()`** 使用该屏幕的默认颜色映射，返回映射为黑色和白色的像素值。这些宏旨在用于单色程序，以便它们能在单色、灰度或彩色显示器上工作。在彩色硬件上，黑和白的颜色可能实际上不是黑和白，但它们保证是有对比的。


## 像素图和可绘图（Pixmaps and Drawables）

窗口不是唯一有效的绘图目的地（**valid destination**）。像素图也是大多数图形请求的有效目的地。像素图是服务器中的一个屏幕外内存块。窗口和像素图被统称为 ***drawables*** 。

像素图是一个像素值的数组。它有一个深度，就像一个窗口。然而，它没有相对于任何其他窗口或像素图的位置属性，也没有窗口属性（如颜色映射）。所有这些东西只有在像素图被复制到一个窗口时才会影响它，**而像素图只有在被复制到窗口时才变得可见** 。

有几个可以创建像素图的函数，最简单的是 **`XCreatePixmap()`** ，它创建一个未定义内容的 **空像素图** 。在使用用 **`XCreatePixmap()`** 创建的像素图后，一定要记得清除它，否则它可能变成内存垃圾（使用后没有释放它的内存，C语言中看作内存垃圾或者内存泄露）。其他几个函数创建像素图，并从存储在文件中的数据填充一个像素图，这些函数将在后面提到像素图的各种用途时进一步介绍。

有些例程只在像素图上或只在窗口上操作。这些例程将 **Pixmap** 或 **Window** 作为参数，如果允许其中之一，Xlib 例程的参数将被指定为一个 **Drawable** 类型。所有的这些绘图例程都使用 **Drawable** 参数类型。

一个像素图不容易被其他窗口所覆盖，另外，窗口只有在可见的情况下才能被画出来，因为它们的内容在被遮挡或未被映射时不会被服务器记住（除非服务器备份存储功能可用且有效）。

要用 **`XCopyArea()`** 复制一个像素图到到另一个窗口，像素图的深度必须与它要复制到的窗口相同。一旦复制，与窗口相关的颜色映射将被用于把像素图的像素值转换为实际可见颜色。拷贝后，拷贝到像素图中的额外绘图不会出现在窗口中。用 **`XCopyPlane()`** 可以将任何深度的像素图的一个平面复制到任何窗口（保证窗口颜色深度于像素图一致）。

简而言之，窗口的缺点是，当它们不可见时，对它们绘图不会有任何作用。像素图代表了屏幕的一个区域，它驻留在内存中，可以在任何时候被画到。不幸的是，像素图必须在用户看到它们之前被复制到一个可见窗口，这种复制会对性能产生影响。也许更重要的是，服务器中用于像素图的屏幕外内存的数量可能是有限的，因此，使用大量像素图的程序可能造成程序卡顿甚至因内存不足无法在PC服务器和X终端上运行。

一个深度为 1 的像素图被称为位图（ **bitmap** ），尽管没有单独的类型或资源称为位图。位图是一个二维的位阵列，可用于许多用途，包括光标定义、字体和双色图片的模板等。每个位代表一个单一的像素值，它要么被设置 1，要么被设置 0 。根据视觉类型的不同，这些像素值可以被解释为两种颜色或简单地解释为黑与白。


## 绘图与图形上下文（Drawing and the Graphics Context）

与任何图形语言一样，X提供了绘制 **点** 、**线** 、**矩形** 、**多边形** 、**弧线** 、**文本** 等的例程。绘制图形的例程一般被称为图形基元（graphics primitives）。但在 X 中，一个给定的图形基元并不包含绘制一个特定图形所需的所有信息。一个叫做 **图形上下文（GC）** 的 **服务器资源** 指定了其余的信息，比如线宽、颜色和填充模式等。**`GC`** 的 ID （类似于窗口ID）被指定为相关绘图例程的一个参数，它可以定制被绘制到窗口的图形的一切的外观。

在进行任何绘图之前，客户端必须创建 **`GC`** 。创建的 GC 被存储在服务器中，因此它所包含的信息不必与每个图形基元一起发送，只需传递其 ID 。这大大改善了绘图的性能，因为它减少了 Xlib 和服务器之间连接的流量，**所有 GC 设置都适用于使用该 GC 绘制的所有图形** 。

可以创建一个以上的 GC，并且每个 GC 可以设置不同的值。这允许程序在不同 GC 之间切换，用同一个图形基元获得不同的效果。

## 瓦片和点缀（Tiles and Stipples）

当像素图被用于绘制一个区域的图案时，例如窗口的背景或 GC 中的背景，它们通常被称为瓦片或点缀。

瓦片是一个像素图，其深度与它用于图案的可画性相同。瓦片通常是 16x16 像素，但可以是其他尺寸（某些尺寸绘制得更快，这取决于硬件）。它通常只由两个不同的像素值组成，因为这是最容易创建的类型，但也允许多个像素值。任何绘图例程绘制的区域都可以通过在 GC 中放置某些值来平铺，窗口的背景和边界可以通过在窗口属性中指定一个像素图而被平铺。

点缀是深度为1的像素图，点缀与前景像素值，有时与背景像素值一起使用，以类似瓦片的方式对一个区域进行图案化。在图形上下文中，有两种可以设置的点缀样式。在一种情况下，点缀中的设定位以前景色绘制，未设定位以背景色绘制。在另一种情况下，只有点缀中的设定位被绘制在前景像素值中，而点缀中未设定位所代表的目标像素不会被改变。像平铺一样，渐变只影响那些被图形请求选中的像素，比如为一条线或一个字符绘制的像素。点缀只存在于 GC 中，不能用于窗口背景。

---

#### [上一节](./2.md)

#### [下一节](./4.md)
