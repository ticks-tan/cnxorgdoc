# 事件介绍

本节将对事件进行简要介绍，你将需要这些知识来完全理解 **第3章 "基本窗口程序"** 和 **第4章 "窗口属性"** 中描述的一些窗口属性。在 **第8章 "事件"** 和 **第9章 "键盘和指针"** 中，将更全面的介绍事件。

## 什么是事件？

移动鼠标指针或按下键盘按键会导致一个输入事件的发生，这是最简单和最常见的两种事件类型，但还有许多其他类型的事件。事件是一个包含事件信息的包，当某些动作发生时由服务器产生，发送给客户端由客户端将其放入事件队列供程序使用。队列中的事件可以在随后的任何时间以任何顺序被读取，但它们通常是按照它们发生的顺序被读取和处理。

下面是一组其他类型的事件：

- 鼠标（或其他指针）按钮被按下或释放。( **`ButtonPress`** , **`ButtonRelease`** )
- 窗口被映射或取消映射。( **`MapNotify`** , **`UnmapNotify`** )
- 鼠标进入或者离开窗口边界。( **`EnterNotify`** , **`LeaveNotify`** )

这些事件类型通常用于用户输入和控制用户界面 。

第二组事件报告窗口操作产生的事件。例如，当一个窗口在被遮挡后变得可见时，它会收到一个 **`Expose`** 事件。当窗口的定位（当父体被调整大小时控制窗口位置的窗口属性）生效时，会产生一个 **GravityNotify** 事件。

- 客户端可以要求将所有的键盘输入发送到一个特定的窗口，而不管鼠标指针的位置在哪儿，这被称为一个键盘焦点窗口。将键盘焦点从一个窗口转移到另一个窗口会引起 **`FocusIn`** 和 **`FocusOut`** 事件，向客户端表明它是否可以进行进一步的键盘事件。
- 改变键盘按键映射会导致一个 **`MappingNotify`** 事件被发送到所有客户端。
- 重置一个窗口有时是由窗口管理器来完成的，以便为屏幕上的窗口添加一个UI框架。这个动作会引起一个 **`ReparentNotify`** 事件。
- 当客户端改变窗口的一个属性时，会产生 **`PropertyNotify`** 事件。
- **`SelectionClear`** 、**`SelectionNotify`** 和 **`SelectionRequest`** 事件被用来在允许用户选择一段文本（或其他信息）的客户端和允许用户将信息放在其窗口内的客户端之间来回通信。其中一些事件是用 **`XSendEvent`** 发送的。

在这一点上，我们只需要大致了解什么是事件，而不是准确了解每个事件的用途或如何使用它们。 **第8章 "事件"** 和 **第9章 "键盘和指针"** 将提供更完整的细节。

## 事件的选择与传递

客户端必须选择它希望服务器为每个窗口发送的事件类型。选择是通过调用 **`XSelectInput()`** 来实现的，它设置了 **`event_mask`** 窗口属性，通过更通用的 **`XChangeWindowAttributes()`** 例程设置该属性，或者在调用 **`XCreateWindow()`** 时指定。

例如，滚动条可能需要鼠标按钮事件，但不需要键盘事件，而一个应用程序的主窗口可能需要键盘事件，但不需要鼠标事件。通常会在这些窗口中选择不同的事件类型。

键盘和指针事件在距离指针最近的最小窗口中产生。然后，这些类型中的一个事件（仅）通过窗口层次结构向上传播，直到在窗口的 **`event_mask`** 或 **`do_not_propagate_mask`** 属性中找到该事件类型。如果事件首先在 **`event_mask`** 中被发现（或者在同一窗口的两者中被发现），那么该事件就会被发送，就像它发生在该窗口中一样，如果它首先在 **`do_not_propagate_mask`** 中被发现，那么它就永远不会被发送。最终收到该事件的窗口的 ID（如果有的话）被放在事件结构的 **`window`** 成员中。

**`do_not_propagate_mask`** 只能通过 **`XChangeWindowAttributes()`** 或 **`XCreateWindow()`** 设置。除键盘和指针事件外，其他事件不传播。当适当的操作发生时，它们会出现在选择它们的窗口中。

对于大多数类型的事件，如果每个客户端都在该窗口上选择了该事件类型，那么一个事件的副本可以被发送到一个以上的客户端。每个客户端对每个窗口都有自己的事件掩码，创建窗口的客户端不需要做任何事情来配合。其他想从一个不是它创建的窗口获得事件的客户端只需要找出该窗口的 
ID ，然后用 **`XSelectInput()`** 在该窗口上选择所需的事件类型。一个重复的事件被发送到每个窗口，这些事件通过两个应用程序的层次结构独立传播，不过这种情况很少发生，因为除了窗口管理器之外，通常没有理由让任何程序操控另一个应用程序的窗口。

## 事件队列

每个客户都有自己的事件队列，按照服务器发送的顺序接收选定的事件并放入队列。

然后，客户端可以在任何时候删除每个事件，并根据其类型和每个事件结构中的其他信息来处理它。有几个获得输入的功能，它们在监测多少个窗口和寻求什么类型的事件方面有所不同。客户端还可以读取队列中的事件而不将其删除、删除一个后再放回去、或者通过丢弃（获取事件但不处理）所有事件来清除队列。**事件也可以由程序创建，并发送至窗口管理器或其他程序** 。

## 事件结构体

**`Expose`** 是最重要的事件类型之一，其事件结构如 **例2-1** 所示。当一个窗口的某个区域在屏幕上变得可见时，它就会产生，并表明客户端必须重新绘制该区域。这发生在一个窗口被映射、移动、调整大小或取消标识的时候，或者一个遮挡的窗口被取消映射的时候。曝光事件是很常见的，并且可以在任何时候发生，因为它们可能是由其他客户端的行为引起的。

例 2-1 ：

```c
typedef struct {
    int type;
    unsigned long serial; // 服务器处理的最后一个请求的数量
    Bool send_event;      // 如果这来自于SendEvent请求，则为真。
    Display* dislay;      // 该事件从哪个 Display 读取的
    Window window;
    int x, y;
    int width, height;
    int count;            // 如果为非零，则更多的Expose事件会在之后发生
} XExposeEvent;
```

事件的类型在每个事件结构中都有指出（在 **`XExposeEvent`** 结构中，**`type`** 成员值是符号常数 **Expose** ）。除了特殊的五种事件类型（处理选择和图形曝光的事件）外，其余的事件传播到的窗口都会在 **`window`** 成员中指出。事件结构中的所有其他信息都是特定于某些事件类型的（不同类型有不同的信息），这些会在之后的教程中提到。

## 事件循环

因为事件可以以任何顺序到达，处理它们的代码结构是预先确定的。每个程序都包含一个 **事件循环** ，在这个循环中，每个事件都被接收然后处理。通常情况下，这个循环被实现为一个无限的 **while** 循环，从一个事件获取函数开始，然后是一个 **switch** 语句，根据事件类型进行分支。在一个事件类型的每个分支中，可能有额外的分支与事件发生的窗口或事件结构中的其他字段相对应。

该循环几乎总是包括 **Expose** 事件。X 通常不会跟踪窗口被遮挡区域的内容。程序有责任确保当 **Expose** 发生时，窗口内容可以被重新绘制。程序必须准备好在任何时候接收 **Expose** 事件并对其采取行动，也就是说在每次调用事件获取函数时，如果没有其他程序在运行，程序可以完美地工作而不用重新绘制，但在窗口环境中这是不太可能的！

当一个窗口第一次被映射时，程序的第一个功能应该是读取映射窗口所产生的 **Expose** 事件，然后，程序可以绘制窗口的内容。事实证明，这也是当曝光事件在任何后来的时间到来时，程序应该做出的反应。第一次绘制和后来的重绘是以完全相同的方式完成的，使用的是相同的代码。使用相同的代码，以同样的方式完成。

然而，必须注意的是另一种类型的事件：**`ConfigureNotify`** ，必须被处理，以防窗口管理器在映射前修改应用程序的大小，也以防用户在之后调整窗口的大小。关于这一点，在 **第三章 ”基本窗口程序”** 中会有更多介绍。

---

#### [上一节](./4.md)

#### [下一节](./6.md)

