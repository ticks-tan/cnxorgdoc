# Xlib如何工作

让我们先描述 X 被设计用来解决什么问题，再描述它是如何解决这些问题的。

首先，X 的设计是为了在位图终端上提供窗口。这一点以前也做过，但不是以一种可以轻松移植到许多不同品牌的硬件上的方式设计的，从PC到超级计算机。代码被设计成强调容易移植，甚至在不同的操作系统之间，但仍然允许高性能。

第二，X 被设计成允许许多不同类型的机器在一个网络中合作，这是 X 设计中的主要创新之一。有几个标准的网络协议，但缺乏一个被广泛采用的更高层次的协议标准，指定应该通过网络发送什么来驱动一个窗口系统。关于X的第一件事是确定用于在网络上通信的协议。

第三，X 的开发者决定，它不应该要求（甚至暗示）一种特定风格的用户界面。实际上，如果 X 暗示了一个与他们的专有窗口系统不兼容的用户界面，那么它就不会被许多公司采纳为一个标准。此外，X 的开发者认为，围绕X的基于窗口的用户界面的设计问题目前还没有充分解决。因此，一个重要的设计目标是使 X **"无策略"** 。

为了实现这些目标，X窗口系统 必须从下往上设计。为了在网络上工作，必须有程序在连接的两端运行，以发送和接收信息并解释它。控制显示和输入设备的那一端被称为 **服务器** 。在另一端是 **客户端** ，使用 Xlib 编写的程序来与 X协议接口 。

实际上，尽管本手册描述的是 Xlib，即X协议的C语言接口，但也有一个 Lisp 接口，而且可能还有其他接口。任何能够产生和接收 X协议 请求的语言绑定都可以与服务器通信，并与X窗口系统一起使用。但是，目前，Xlib 是与 X 一起使用的最流行的低级编程接口，因为C语言是如此广泛地可用。

## X协议

X协议规定了构成服务器和 Xlib 之间双向传输的每个信息包的内容。即使服务器和 Xlib 运行在同一台机器上，该协议也能用于通信（通过一些内部通道而不是外部网络）。有四种类型的数据包通过协议被传输：**请求** 、**回复** 、**事件** 和 **错误** 。

**协议请求是由 Xlib 生成并发送给服务器的。** 协议请求可以携带各种各样的信息，例如，画一条线或改变颜色图中一个单元格的颜色值的规范，或询问一个窗口的当前大小。大多数 Xlib 例程会产生协议请求。例外情况是只影响 Xlib 本地的数据结构而不影响服务器的例程。

协议回复是由服务器发送至 Xlib 以回应某些请求的。**不是所有的请求都会被回复，只有那些要求信息的请求才会被回复。** 例如，指定绘图的请求不会产生回复。当 Xlib 收到一个回复时，它将请求的数据放入生成请求的 Xlib 例程的参数或返回值中。一个需要回复的 Xlib 例程被称为一个往返的请求。**在客户端中必须尽量减少往返请求，因为当有网络延迟时，它们会降低性能。**

一个事件从服务器发送至 Xlib，包含了关于设备动作的信息或关于先前请求的异常的信息。事件中包含的数据是相当多的，因为它是客户端获得信息的主要方法。事件被保存在 Xlib 的队列中，可以由客户端一次读取一个。**服务器发送给客户端的事件类型的范围是由客户端指定的。**

一个错误告诉客户端以前的请求是无效的。一个错误就像一个事件，但它在 Xlib 中的处理方式略有不同。**错误不能被读取事件的 Xlib 调用所读取。** 相反，错误被发送到 Xlib 的一个错误处理例程。默认的错误处理程序只是打印一个消息并退出，它可以被一个客户特定的错误处理程序所取代。

## 缓冲区（Buffer）

Xlib 将请求保存起来，而不是立即将它们发送到服务器，这样客户程序就可以继续运行，而不是在每次 Xlib 调用后等待获得网络访问。这是可能的，因为大多数的 Xlib 调用并不要求服务器立即采取行动。**在通过网络发送请求之前，客户端对请求进行分组 ，这也提高了大多数网络的性能，因为它使网络事务更长，数量更少，减少了涉及的总开销。**

Xlib 在以下三种情况下将充满请求的缓冲区发送到服务器：

- 最常见的是当一个应用程序调用 Xlib 例程来等待一个事件，但目前在 Xlib 的队列中没有匹配的事件。因为在这种情况下，应用程序无论如何都必须等待一个合适的事件，所以冲刷请求缓冲区是有意义的。
- 第二，从服务器获取信息的 Xlib 调用需要在程序继续之前得到回复，因此，在信息返回之前，请求缓冲区被发送并对所有的请求进行操作。
- 第三，客户端希望能够在没有用户事件和没有查询服务器的调用的情况下，手动冲刷请求缓冲区。这第三种情况的一个很好的例子是一个动画游戏，即使没有用户输入，显示也会改变。

让我们来看看这在实践中是如何工作的：

1. 当应用程序启动时，所有创建应用程序初始外观的请求都被 Xlib 加入发送队列。
2. 应用程序进入它的事件循环并调用 **`XNextEvent()`** 。由于还没有任何东西被发送到服务器上，所以屏幕还没有显示窗口，因此也没有事件被生成。所以 **`XNextEvent()`** 请求会导致所有的请求被发送到服务器上，从而显示出应用程序界面。
3. 同时，应用程序仍然在等待第一个用户输入。当用户移动鼠标或按下按钮或按键时，服务器在网络允许的情况下立即将事件发送给Xlib ，这时 Xlib 不会对它们进行排队或分组（**除了在第9.4节 "抓取键盘和指针 "中讨论的涉及抓取的罕见情况** ）。通常情况下，一旦一个事件到来，应用程序就会产生更多的请求来绘制（例如，突出一个按钮的边界）。这些请求在 Xlib 中保持排队状态，直到所有已经到达的事件被处理完。
4. 一旦应用程序再次执行到 **`XNextEvent()`** ，并且队列中没有更多的事件，队列中的请求就会被发送到服务器上，这个过程又循环到开始情况了。

使用 Xlib 调用，客户端可以通过三种方式刷新连接。
- 调用一个需要立即回复的例程（名称中含有 **`Query`** 、**`Fetch`** 或 **`Get`** 的例程）。
- 当 Xlib 的队列中不存在匹配的事件时，调用某些事件读取例程。
- 调用例程 **`XFlush()`** 或 **`XSync()`** 。

其中第一个方式对服务器说："我需要一些信息，请马上对这些请求采取行动，然后给我信息"。

第二个方式对 Xlib 说："我正在等待某种事件，所以我将检查你是否已经把事件发送到服务端。如果没有，请立即对这些请求采取行动，然后我等待事件的发生"。

最后一种说："我现在不需要你的任何信息，但我需要你立即对这些请求采取行动“。 通常情况下，最后一种方法用得不多，因为在客户端有足够多的前两种类型的 Xlib 调用，使沟通足够频繁。

你应该已经知道，**Xlib 维护着一个应用程序所连接的每个服务器的事件队列** 。每当事件从服务器到达时，它们就被排在队列中，直到客户端读取它们。

Xlib 对输入和输出进行排队的行为在应用程序编程中非常重要，特别是在调试中。这意味着，在请求缓冲区被刷新之前，绘图请求不会出现在窗口中。这意味着在请求到达服务器并被处理之前，错误不会被服务器发现，而这只发生在 Xlib 刷新请求缓冲区之后。一旦发现，错误会立即报告给客户端。换句话说，在一个较早的例程引起的错误被报告之前，可能要调用几个 Xlib 例程。这是两个最明显的例子，说明了缓冲区的作用。可以参见 [第2.6.3节 "调试X应用程序"](#) ，了解更多关于缓冲如何影响编程和调试的细节。

## 资源（Resources）

X 使用好几种技术来减少网络流量。一个主要的技术是让服务器维护复杂的抽象概念，如窗口或字体，并 **让客户端为每个抽象概念分配一个整数的 ID 号作为昵称。这些抽象概念中的每一个都被称为一个资源 。一个资源可以是一个窗口、像素图、颜色图、光标、字体或图形上下文** （这些将在稍后描述）。

每当要对一个窗口（或任何其他资源）进行操作时，该窗口的 ID 被用于 Xlib 例程的一个参数中。这意味着，在 Xlib 例程调用中，不需要在网络上发送充满数据的整个结构，而只需要发送一个代表该结构的整数。**记住，由于客户端和服务器可能运行在不同的机器上，所以不能用指针来引用结构** 。资源方法的注意事项是，当客户端需要有关资源的信息时，必须查询服务器，如上所述，这将导致网络延迟。不过好在，客户端通常不需要经常查询服务器，而且资源抽象大大简化了程序。

**如果任何客户端知道一个资源的 ID，即使其他客户端创建了该资源，该客户端也可以操作该资源** 。这意味着不止一个客户端可以在同一个窗口中画画，尽管这并不是经常需要的。更重要的是，这就是窗口管理器的实现方式 -- 他们可以移动和调整应用程序窗口的大小，因为他们知道 资源 ID！

需要注意的是，"资源" 一词在 X 中还有另一种用法，与资源管理器有关。在资源管理器的上下文中，资源是一个用户偏好的规范，它控制着应用程序中用户可定制的元素。幸运的是，资源一词的这两种用法适用于 X 的不同部分，因此不难分开。一个用途适用于服务器维护的数据结构，而另一个适用于用户定制的应用程序。

## 属性和原子（Properties and Atoms）

X 的开发者需要一种方法来允许客户机之间相互交流任意的数据，于是他们想到了属性。**属性是一个与窗口相关联的信息包，可以提供给在服务器下运行的所有客户端** 。属性被客户端用来存储其他客户端可能需要或想知道的信息，并在其他客户端设置时读取这些信息。

属性有一个字符串名称和一个称为原子的数字标识符。原子是一个 ID，可以唯一地识别一个特定的属性。属性名称字符串通常都是大写字母，用下划线隔开，例如 **"WM_COLORMAP_WINDOWS"** 。原子被用来指代常规调用中的属性，因此任意长度的属性名称字符串不需要通过网络发送。应用程序通过调用 **`XInternAtom()`** 获得一个属性的原子。你指定属性的字符串名称作为 **`XInternAtom()`** 的参数，然后它返回原子。从此时起，应用程序只使用原子来引用该属性。如果连接到同一台服务器（未被重置），每个使用该属性的应用程序都会在使用相同的属性名称字符串参数调用时获得相同的原子。

一些原子被称为预定义原子，在服务器初始化时被定义。应用程序不需要使用 **`XInternAtom()`** 来获取这些原子。相反，这些原子可以作为以 **`XA_`** 开头的符号常量使用。这些原子标识了属性，其内容有一定的含义，所有客户端都知道。这些属性本身并没有任何内容，直到客户端或窗口管理器为它们设置值。本手册中描述的一些属性有预定义的原子，而其他属性则由于历史原因没有。如果有预定义的原子，比如 `XA_WM_HINTS` ，我们将在文本中使用它们来指代该属性。对于没有预定义原子的属性，我们将使用字符串属性名称，如 
`WM_COLORMAP_WINDOWS` ，它不是以 **`XA_`** 开头。这告诉你在使用该属性之前是否需要调用 **`XInternAtom()`** 。

属性的原子类似于用来指代服务器资源的 ID，不过除了原子和窗口，其他资源 ID 都是唯一标识的（一对一关系）。同样的原子可以用来识别一个窗口和另一个窗口的属性 （在两个窗口上设置或读取这个属性的调用中，只有窗口 ID 是不同的）。在客户端代码中只有 **`Atom`** 类型被使用，属性是由服务器管理的底层数据。

属性最重要的用途之一是将信息从应用程序传达给窗口管理器，反之亦然。应用程序在其顶层窗口上设置标准属性，以指定它喜欢的顶层窗口的尺寸范围和其他信息。这些属性被称为 ”标准“，因为它们是一个应用程序应该指定的最小集合。属性也可以以其他方式进行交流，例如，窗口管理器根据属性指定程序喜欢的图标像素大小。

关于属性和原子的更多信息，可以参阅 [第12.1节 "属性和原子"](#)

## 窗口管理器

**窗口管理器只是另一个用Xlib编写的客户端，但根据惯例，它被赋予了特殊的职责** 。它调解对显示器物理资源的竞争需求，包括屏幕空间和颜色映射。通常，它有一个用户界面，允许用户在屏幕上移动窗口，调整它们的大小，并启动新的应用程序。

大多数窗口管理器用标题栏和各种工具来装饰所有应用程序的主窗口，用于图标化和调整应用程序的大小。窗口管理器通过创建一个单独的窗口来实现这一目的，该窗口适合于每个应用程序的主窗口后面。正是这个单独的窗口上有装饰物。这一点很重要，主要是因为你的应用程序代码不需要处理这种绘制。

客户端和窗口管理器之间的大部分通信是通过属性进行的（其余的是通过事件发生的）。许多属性被称为提示，因为它们不一定会被窗口管理器认可。**一个应用程序必须准备好让窗口管理器忽略、修改或尊重它通过窗口管理器提示指示的偏好** 。属性本身并没有有效的内容，直到应用程序或窗口管理器设置它们。

Xlib（和X协议）的相当多的功能只是为了给窗口管理器提供执行其权限的机制而存在，一般的应用程序不需要它们。

其中一个功能被称为 **子结构重定向** 。子结构指的是一个窗口的大小、位置和子窗口的重叠顺序。重定向指的是应用程序改变这些窗口配置的请求被发送到窗口管理器进行批准，而不是直接发送给服务器实际执行。子结构重定向允许窗口管理器拦截应用程序提出的改变屏幕上顶级窗口的大小、位置、边界宽度或堆叠顺序（统称为窗口配置）的任何请求。任何应用程序改变其顶层窗口配置的请求将被取消，相反，一个事件将被发送到窗口管理器，表明在重新配置请求中使用的参数。然后，窗口管理器可以决定授予应用程序什么尺寸、位置和堆叠顺序，窗口管理器将按照这些尺寸重新配置窗口。对于临时窗口，如弹出式菜单和对话框，可以使用窗口属性关闭子结构重定向功能。

子结构重定向看似晦涩难懂，但它对应用程序有两个重要影响：

1. 首先是 **应用程序不能假定它为一个窗口指定的配置将实际反映在屏幕上的窗口中** 。无论该配置是通过创建窗口还是通过重新配置窗口来设置的，都是如此。这意味着，应用程序必须在绘制窗口之前，始终确定该窗口的新配置。程序可以通过选择一个包含窗口配置的特定事件类型来实现这一点。
2. 第二个重要含义是关于顶级窗口的映射。因为窗口管理程序可以拦截映射请求，而且在窗口管理程序决定窗口配置和映射窗口本身之前可能需要一些时间，所以 **应用程序不能假设窗口是立即可见的。这意味着它不能立即绘制到该窗口中。应用程序必须等待，直到它收到一个表明窗口是可见的事件，然后再绘制到该窗口** 。

与窗口管理器的通信，以及一般的窗口管理，是一个很长的故事，我们将在 **第3章 ”基本窗口程序（Basic Window Program）“** 和 **第12章 "客户间通信（Interclient Communication）"** 中更全面地描述，并从窗口管理器的角度来描述与应用程序的通信。

今天，大多数窗口管理器也有启动和关闭应用程序的能力。这就是所谓的 **会话管理** 。然而，它们通常只能启动 xterm 和其他一些基本的客户端。一个真正的会话管理器可以是一个独立的客户端。它能够启动任何客户端并控制其命令行参数，并保存整组客户端的状态（在用户注销之前），随后将它们恢复到屏幕上的相同位置（当用户重新登录时）。这种水平的能力还没有实现（但人们正在努力实现）[^1] 。每个应用程序都将其命令行作为提示提供，以便窗口或会话管理器有足够的信息在其当前状态下重新启动它。

现在你应该对 Xlib 的工作原理有了一个概念。下一节我们将进一步对 **窗口（windows）** 进行描述。

---
#### [上一节](./0.md)

#### [下一节](./2.md)

[^1]: 翻译教程时已经实现，本书出版较早，有部分内容有误，无伤大雅。