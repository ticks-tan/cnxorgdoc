# 什么是窗口？

一个 X 服务器控制着一个屏幕。为了便于同时查看和控制许多不同的任务，这个屏幕可以被分割成更小的区域，称为窗口。窗口是一个长方形的区域，它在几个方面都像一个微型屏幕。屏幕上的窗口可以被安排成全部可见，或者完全或部分地覆盖对方。一个窗口可以是大于零的任何尺寸。

每个窗口（在运行 X 的屏幕上）都可以参与不同的活动，当前正在使用的窗口被放置在那里，使它们至少有一部分是可见的。窗口管理器可以让你在必要时将不同的窗口移到顶部，或者重新安排窗口的大小和位置。

## 窗口特征

即使你已经熟悉了窗口系统，也要阅读这一节，以确保你理解 X 对窗口系统的特殊实现。

窗户的特征有哪些？有很多。

首先，一个窗口总是有一个父窗口，这个窗口在创建时被指定。每个窗口都被包含在其父窗口的范围内。窗口不能在自身之外的区域显示输出，当指针在自身之外时，也不能从键盘或指针接收输入（除非抓取或键盘焦点生效，如 8.3.2.1 和 8.3.2.2 节中所述）。每个窗口都适合于由其子窗口、其父窗口、其父窗口的父窗口等设置的层次结构中。**有一个窗口，也是唯一一个没有父窗口的窗口，被称为根窗口（Root WIndow），它充满了整个屏幕。根窗口是由 X 服务器在启动时创建的** 。

其次，每个窗口都有自己的坐标系。一个窗口坐标系的原点是窗口的左上角，x 和 y 坐标向右和向下增加。

在X窗口系统中：

- 横轴是 x ，纵轴是 y 。

-  x 和 y 在当前使用的窗口边框（如果有的话）内的左上角为0。这个点被称为窗口的原点。

- 坐标向窗口的右侧和底部增加。

- 坐标是整体的，与像素中心相吻合。

所有用于放置图形和定位子窗口的测量都是从原点开始的。**当我们说一个点时是相对于一个窗口的，这意味着该点的 x 和 y 坐标是从窗口的原点开始测量的** 。

每个窗口在创建时都有一个唯一的识别号（ID）。所有影响一个特定窗口的例程都会使用窗口 ID 作为参数，并在这个窗口环境中操作，因此窗口中的位置是相对于窗口边界内的左上角指定的。**在定位子窗口或者在窗口中绘制时没有必要知道一个窗口在屏幕中的位置** 。

例如，使用 **`XCreateWindow()`** 或 **`XCreateSimpleWindow()`** 创建一个窗口时，你需要提供一个从父窗口左上角的偏移量来定位新窗口。当父窗口移动时，新窗口保持在相对于其父窗口相同的偏移位置。

一个窗口有一个位置，相对于它的父窗口角落，即它的左上角定位，边框内有一定的宽度和高度的可用像素，还有一个边框宽度。按照惯例，窗口的宽度和高度不包括边界。由于几个窗口可能有相同的父窗口，所以一个窗口还必须在这些窗口之间有一个堆叠顺序，以确定在它们重叠的情况下哪些窗口将被看到。这几个特征被统称为窗口配置，因为它们影响着屏幕上的窗口布局。

概括地说，窗口配置包括：

- 窗口的宽度和高度，单位是像素，不包括边框。
- 窗口的边框宽度可以变化，零会使边框不可见。
- 一个窗口在屏幕上的特定位置，由 x 和 y 坐标指定，以像素为单位，从父窗口的原点（左上角，边界内）到子窗口的左上角（子窗口边界外）。
- 一个窗口在具有相同父级的窗口中有特定的堆叠顺序。

**宽度** 、**高度** 和 **位置** 统称为窗口的几何形状。应用程序通常允许用户以命令行参数或通过用户默认机制指定窗口的几何形状和边界宽度。

一个窗口有被称为深度和视觉的特性，它们共同决定了它的颜色特性。深度是指每个像素可用来表示颜色（或灰度）的比特数。视觉表示像素值被转换为在显示器上产生彩色或单色输出的方式。

一个窗口有一个 **`InputOutput`** 或 **`InputOnly`** 的类别。正如名字所暗示的，**`InputOutput`** 窗口可以接收输入，也可以用来显示输出，而 **`InputOnly`** 窗口只用于输入。**不存在纯输出的窗口，因为某些类型的输入，称为事件，是所有窗口都需要的** 。

一个窗口有一组属性，窗口属性控制着窗口的外观和反应的许多方面，比如：

- 窗口的边框和背景用的是什么颜色或图案？
- 在调整大小的过程中，部分窗口内容是如何重新定位的？
- 当窗口的内容被覆盖后又被暴露出来时，什么时候会自动保存？
- 哪些事件类型被接收，哪些类型被丢弃（不传递给祖先窗口）？
- 是否应该允许这个窗口在不通知窗口管理器的情况下被显示、移动或调整大小？
- 哪种颜色映射被用来解释这个窗口中绘制的像素值？
- 当指针在这个窗口中时，应该显示哪个光标？

这似乎是一个令人眼花缭乱的一组属性，但在实践中，它们中的许多都提供了合理的默认值，程序员可以安全地忽略掉，而且它们提供的灵活性使系统更加强大。所有这些窗口特性将在本章后面详细解释，而且大多数将在本手册后面再次涉及。

但首先，有必要对 X 的基本框架进行更详细的介绍：**窗口的层次结构** 、**堆叠顺序** 和 **包装** 的概念。这些都是接下来三节的内容。

## 窗口的结构层次

窗口的层次结构就像家庭树一样，只不过创建一个子窗口只需要一个父窗口。每个屏幕都有一个单独的层次结构。最上面的是根窗口，它充满了整个屏幕，在服务器初始化时创建。每个客户端要创建的第一个窗口都是根窗口的子窗口。在客户端第一次调用 **`XCreateWindow()`** 或 **`XCreateSimpleWindow()`** 创建窗口时，根窗口是其父窗口。

根窗口的子窗口很特别，因为它们是每个应用程序的顶级窗口，它们由窗口管理器管理。**第3章 "基本窗口程序"** ，会描述在显示、移动或调整该窗口的大小之前，客户端需要完成的特殊步骤。

每个子窗口也可以有自己的子窗口。这些顶层窗口的子窗口被用来创建应用功能，如命令按钮和滚动条。

**图 2-1** 显示了可能出现在屏幕上的窗口层次结构，**图2-2** 显示了同一层次结构的示意图。注意，窗口A到D代表每个应用程序的子窗口，在实际应用中可能不会像这样重叠。通常情况下，子窗口被用作命令按钮或窗格，以非重叠的方式布置。然而，这个假想的层次结构有助于展示堆叠顺序和窗口层次结构的效果。

图 2-1：

![[Figure-2-1.svg]]

图 2-2：

![[Figure-2-2.svg]]

一个子窗口可以部分或完全位于其父窗口之外，但对子窗口的输出只在子窗口与父窗口重叠的区域内显示和接收输入。图2-1 显示了子窗口不会超出父窗口的边界，即使它们的定位方式会与父窗口的边缘重叠。(例如，在 图2-1 中，窗口A 不会超出 窗口1 的左边，即使它的宽度表明它应该这样做）。如果一个窗口的移动方式使其超出了父窗口的范围，它就会被剪掉，这样就只有与父窗口重叠的部分被显示 。

下面这些是用来描述窗口层次结构子集的术语：

- **Parent：**  创建子窗口时指定的窗口将作为子窗口的父窗口。
- **Child：**  一个以另一个窗口为父窗口创建的窗口。
- **Subwindow：**  与孩子同义，不同于后代。
- **Siblings：**  有相同父窗口的窗口（类似于兄弟姐妹）。
- **Descendants：**  窗口的子女，子女的子女，等等。子孙都可以称为下级。这个术语比子窗口或子窗口的子窗口更具包容性，因为它可以包括窗口层次结构中的很多代。
- **Ancestors：**  一个窗口的父窗口，父窗口的父级，以此类推，包括根窗口。祖先都可以被称为上级。

## 窗口堆叠顺序

当一个窗口与它的一个同级窗口重叠时，在上面的窗口会遮住另一个窗口的一部分。**堆叠顺序决定了哪个窗口出现在上面** 。这个顺序可以通过各种例程来改变，使窗口相对于其同级窗口上升、下降或循环。这些例程只影响一组兄弟姐妹和他们的后代，但不影响他们的祖先。

子窗口始终位于其父窗口的前面。当具有子窗口的窗口按堆叠顺序移动时，其所有子窗口都会随之移动，就像它们在移动一样（因为基于窗口的坐标系）。

上面 **图2-6** 和 **图2-7** 显示了屏幕上的一组窗口及其层次结构，如果你仔细观察，就可以看到堆叠顺序是如何影响每组同级窗口的。需要注意，窗口2 在 窗口C 和 窗口1 的所有其他子窗口之上！

## 映射和可见性（Mapping and Visibility）

新创建的窗口不会立即出现在屏幕上。它是一个抽象的实体，不能被绘制到屏幕（除非在该服务器上实现了一个支持存储功能，本节后面会讨论，并且打开了合适的窗口属性）。映射将一个窗口标记为符合显示条件。如果它没有被同级窗口或祖先的同级窗口所遮挡，它就可能是可见的，只有这样它才能被绘制到屏幕上。

**`XMapWindow()`** 将一个窗口映射到它在堆叠顺序中的当前位置，而 **`XMapRaised()`** 在映射前将该窗口放在其兄弟姐妹的堆叠顺序的顶部。**对于一个从未映射过的新窗口，这两个调用是等价的，因为新窗口的初始堆叠位置是在顶部** 。

在你有机会看到一个窗口之前，你必须对其进行映射，但仅仅这样做是不够的。有许多因素会影响任何窗口，无论是新创建的还是已经映射的，满足下面规则将会是可见的：

1. 窗口必须用 **`XMapWindow()`** 或相关例程进行映射。
2. 该窗口的所有祖先必须被映射。
3. 该窗口不能被可见的同级窗口或祖先的同级窗口所遮挡。如果同级窗口是重叠的，窗口是否被遮挡取决于堆叠顺序。堆叠顺序可以用 **`XCirculateSubwindows()`** 、**`XConfigureWindow()`** 和 **`XRestackWindows()`** 进行操作。
4. 请求缓冲区必须由获取事件的例程，通过调用XFlush()，或由从服务器请求信息的函数来刷新。在 **第2.1.2节 ”缓冲区“** 中提供了更多关于这个主题的信息。
5. 顶层窗口的初始映射是一个特殊情况，因为窗口的可见性可能会被窗口管理器延迟，这是因为在 **第2.1.5节 "窗口管理器"** 中简要介绍了子结构重定向。由于复杂的原因，客户端必须等待第一个 **"Expose"** 事件，然后才能假设其窗口是可见的，并在其中绘图。在这一点上，理解为什么是这样并不重要。

这些规则的一个重要后果，也是造成它们的原因之一，就是取消对一个窗口的映射（用 
**`XUnmapWindow()`** ），这会从屏幕上清除该窗口和它的所有子代。X允许你（或者说，实际上是指窗口管理器）控制整个客户端的位置和可见性，由于客户端是由一个顶层的窗口组成的，所以只需操作顶层的窗口。

窗口配置和窗口属性需要在窗口取消映射时被保留，因为X服务器不会自动保留一个窗口的可见内容。对一个不可见或未映射的窗口的图形操作没有任何效果。窗口中可见的图形将在该窗口被遮蔽后再被暴露时被擦除。由于这些原因，客户端必须准备好在需要时重新绘制窗口的内容，在 **第2.5节 “事件介绍”** 中会进一步介绍。

在一些高性能的服务器上，有一个 "备份存储 "的功能，当一个窗口未被映射或被其他窗口覆盖时，该功能可以维护窗口的内容，这样，当该窗口再次变得可见时，就会自动刷新当前内容。**这个功能在计算资源方面是很昂贵的，应该只对那些内容难以重新创建的窗口调用** 。在许多类型的设备上，这个功能不被支持，所以为了可移植性，程序应该能够以其他方式重新创建其窗口的内容。这种可移植性在 X 中特别重要，因为网络环境经常采用各种品牌的设备。

这里提一句，映射是通过 **`XMapWindow()`** 或 **`XMapSubwindows()`** 程序完成的。解除映射是通过 **`XUnmapWindow()`** 或 **`XUnmapSubwindows()`** 例程完成的。

---
#### [上一节](./1.md)

#### [下一节](./3.md)

